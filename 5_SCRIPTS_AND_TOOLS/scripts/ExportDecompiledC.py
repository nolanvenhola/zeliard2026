# Export all decompiled functions to C files
# @category Export

from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor
import os

def run():
    decompiler = DecompInterface()
    decompiler.openProgram(currentProgram)

    # Get output directory from script args or use default
    if len(getScriptArgs()) > 0:
        output_dir = getScriptArgs()[0]
    else:
        output_dir = "decompiled"

    # Create output directory
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Get base name without extension
    base_name = currentProgram.getName()
    if '.' in base_name:
        base_name = base_name[:base_name.rfind('.')]

    output_file = os.path.join(output_dir, base_name + "_decompiled.c")

    print("Decompiling to: " + output_file)

    with open(output_file, 'w') as f:
        f.write("/* Decompiled from " + currentProgram.getName() + " */\n")
        f.write("/* Generated by Ghidra */\n\n")

        function_manager = currentProgram.getFunctionManager()
        functions = function_manager.getFunctions(True)
        count = 0

        for function in functions:
            monitor.checkCanceled()
            monitor.setMessage("Decompiling " + function.getName())

            results = decompiler.decompileFunction(function, 30, monitor)

            if results and results.decompileCompleted():
                f.write("// Address: " + str(function.getEntryPoint()) + "\n")
                f.write(results.getDecompiledFunction().getC() + "\n\n")
                count += 1
            else:
                f.write("// Failed to decompile: " + function.getName() + "\n")
                f.write("// Address: " + str(function.getEntryPoint()) + "\n\n")

        print("Successfully decompiled " + str(count) + " functions")

    decompiler.dispose()

run()
